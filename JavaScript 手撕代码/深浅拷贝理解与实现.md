## 深浅拷贝概念理解

JS 数据类型分为基本数据类型和引用数据类型，浅拷贝和深拷贝的行为在对基本类型时无区别，都是拷贝其值，两者的区别，主要体现在对引用类型的处理上

**浅拷贝的行为是只进行第一层复制**，对基本类型的属性进行值拷贝，对引用类型的属性进行内存地址拷贝(因此嵌套的引用类型，修改还是会互相影响)

**深拷贝是递归复制对象的所有层级**，从原对象上完整拷贝出一个新对象，新对象和原对象互不影响，也不相等

## 浅拷贝的实现方式

- `Object.assign()` 或展开运算符 `...`
- `Array.prototype.slice()` 或 `Array.prototype.concat()`
- lodash 库的 `_.clone()` 方法
- 手写实现浅拷贝 `shallowClone` 函数

```js
function shallowClone(target) {
  //如果值为null或者不是对象的情况，就返回原值，不需要拷贝
  if (target === null || typeof target !== "object") {
    return target;
  }
  // 开辟新的内存空间，处理数组和对象
  const cloneTarget = Array.isArray(target) ? [] : {};
  /**
   * 属性遍历，考虑是否可枚举情况
   * Object.keys 返回自身可枚举属性的数组
   * Object.prototype.hasOwnProperty 判断属性是否为对象自身的属性
   */
  for (let key of Object.keys(target)) {
    cloneTarget[key] = target[key];
  }
  return cloneTarget;
}

const arr = [1, 2, 3, [4, [5]]];
const cloneArr = shallowClone(arr);

cloneArr[3][1] = [6];

console.log(cloneArr); //[1,2,3,[4,[6]]]
console.log(arr); //[1,2,3,[4,[6]]]
```

## 深拷贝的实现方式

- lodash 库的 `_.cloneDeep()` 方法
- 手写实现深拷贝 `deepClone` 函数

实现深拷贝要考虑以下几个方面：

1. 考虑基本类型或 `null` 等情况：**直接返回原值**
2. 处理嵌套的引用类型：**递归处理**
3. 考虑特殊对象类型的处理(Map、Set、Date、RegExp、Promise...)
   - 不可遍历的引用类型，直接返回新实例
   - 可遍历的引用类型，通过原构造函数创建新实例，然后递归处理
4. 处理循环引用导致的爆栈问题：**使用 `Map` 记录已处理对象**
   - 检查当前对象是否已经被处理过，如果处理过，直接返回对应的克隆版本
   - 如果没有处理过，记录当前对象的克隆版本

```js
function getType(obj) {
  return Object.prototype.toString.call(obj);
}

const MAP_TAG = "[object Map]";
const SET_TAG = "[object Set]";
const REGEXP_TAG = "[object RegExp]";
const DATE_TAG = "[object Date]";
const PROMISE_TAG = "[object Promise]";

function deepClone(target, map = new WeakMap()) {
  //如果值为null或者是原始值的情况，返回原值
  if (target === null || typeof target !== "object") {
    return target;
  }

  // 获取目标对象的类型
  const targetType = getType(target);

  // 不可遍历的引用类型，直接返回新实例
  if (targetType === DATE_TAG) return new Date(target);
  if (targetType === REGEXP_TAG) return new RegExp(target);
  if (targetType === PROMISE_TAG) return target;

  // 1. 数据要先进行登记，看是否处理过
  if (map.has(target)) {
    // 1.1 如果处理过，直接返回对应的克隆版本
    return map.get(target);
  }

  // 要保留引用类型的原型链/继承关系，new 一个完全的克隆对象
  const Ctor = target.constructor;
  // 要确保构造函数存在，否则使用空对象
  const cloneTarget = Ctor ? new Ctor() : {};

  // 1.2 否则记录克隆版本
  map.set(target, cloneTarget);

  if (targetType === MAP_TAG) {
    // 递归处理 Map 中的键值对
    target.forEach((value, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(value, map));
    });
  } else if (targetType === SET_TAG) {
    // 递归处理 Set 中的元素
    target.forEach((value) => {
      cloneTarget.add(deepClone(value, map));
    });
  } else {
    // 通用属性递归处理
    for (let key of Object.keys(target)) {
      cloneTarget[key] = deepClone(target[key], map);
    }
  }

  return cloneTarget;
}
```

使用下面这个数据对 `deepClone` 函数进行测试

```js
const sourceObj = {
  num: 100,
  str: "Hello World",
  bool: true,
  nil: null,
  undef: undefined,
  bigInt: 10n,
  info: {
    address: {
      city: "Beijing",
    },
  },
  arr: [1, { a: 2 }, [3, 4]],
  date: new Date(),
  reg: /^1[3-9]\d{9}$/g,
  fn: function () {
    console.log("I am a function");
  },
  set: new Set([1, 2, 3]),
  map: new Map([["key", "value"]]),
};

// 引用自身 --- 循环引用
sourceObj.loop = sourceObj;

const cloneObj = deepClone(sourceObj);

console.log(cloneObj);
```

## 总结

在实现深浅拷贝时，一定要明白它们本质在解决什么问题，即**解决引用类型的拷贝问题**，只是考虑的层级不同，深拷贝会递归处理所有层级的引用类型，而浅拷贝只处理第一层级的引用类型

还有，在手写深浅拷贝时，思路很重要，要先想这个函数要实现什么效果，考虑什么情况，然后用代码实现

## 参考资料

- [MDN - 深拷贝](https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy)
- [lodash - cloneDeep](https://lodash.com/docs/4.17.15#cloneDeep)
- [leader：深拷贝有这 5 个段位，你只是青铜段位？还想涨薪？](https://juejin.cn/post/7017991655009566728?searchId=20251205204308BBAFA07E7F69B570E380)
