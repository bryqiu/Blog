## 防抖函数

防抖与节流是面试中的常客了，遥想在上一次面试中，面试官问过我两者的区别，当时能口述出来区别，但也仅仅是知道概念，真要我手写防抖和节流，就写不出来

防抖（debounce）：即防止抖动，在 n 秒后执行事件，若在这个 n 秒内事件再次触发，则重新计时

防抖函数的应用场景比如说输入框远程搜索，用户在输入框输入内容时，每次输入都要发送一次请求，这对于服务器压力是巨大的，在前端也会造成高频渲染闪烁，我们希望实现一个函数，函数的作用是只有用户输入完成后，才发送请求

```js
const search = debounce(apiFn, 500); // 防抖函数，500 毫秒后执行 apiFn 函数
input.addEventListener("input", search);
```

根据上面的例子，假如要手写一个防抖函数，考虑这些：

- 防抖函数设置两个参数：1.事件，即要执行的函数 2. 时间，多少秒后执行？
- 既然是 n 秒后执行事件，可以用 `setTimeout` 方法延迟执行
- 重新计时如何做？用 `clearTimeout` 销毁之前的定时器，再重新设置一个 `setTimeout` 方法
- 返回一个函数，供调用，就像 `lodash.debounce`

> `setTimeout` 方法返回一个定时器 ID，用变量 `timeoutId` 记住并存储，后续用 `clearTimeout` 方法销毁指定 ID 的定时器

```js
/**
 * 防抖函数
 * @param {function} func 要执行的函数
 * @param {number} wait 执行函数之前应该等待的时间，单位毫秒
 * @returns {function} 具有防抖作用的函数
 */
function debounce(func, wait) {
  let timeoutId;
  return function () {
    // 销毁之前的定时器
    clearTimeout(timeoutId);
    // 设置新的定时器
    timeoutId = setTimeout(func, wait);
  };
}
```

上面这个防抖函数，已经能正常工作了，一个经典例子是：窗口调整事件 `resize`，用户调整窗口大小时，会疯狂触发 `resize` 事件，若要在调整完成后，执行某些操作，防抖函数就派上用场了

```js
// 普通 resize 事件
window.addEventListener("resize", () => {
  console.log("普通 resize: 疯狂触发...");
});
```

![image](https://github.com/user-attachments/assets/4c95a10b-b01c-4206-95cc-e76cc24eb135)

```js
// 防抖 resize 事件
window.addEventListener(
  "resize",
  debounce(() => {
    console.log("普通 resize: 1 秒后停止调整后，执行...");
  }, 1000)
);
```

![image](https://github.com/user-attachments/assets/00174399-077f-44c8-be8a-f0ad357baf0d)

还可以考虑的问题：

- 参数 `fn` 接收一个函数，这个函数当然也可以接收参数
- `this` 指向丢失，要显式绑定 `this` 指向当前上下文

所以最终代码为：

```js
function debounce(func, wait) {
  if (typeof func !== "function") {
    throw new TypeError("func 必须是一个函数");
  }

  // 定时器 ID
  let timeoutId;
  // 上下文
  let context;
  // 参数
  let args;

  return function () {
    if (timeoutId) {
      // 销毁之前的定时器
      clearTimeout(timeoutId);
    }
    // 设置新的定时器
    timeoutId = setTimeout(() => {
      // 函数显式绑定 this，并且接收传入的参数
      func.apply(this, args);
    }, wait);
  };
}
```
