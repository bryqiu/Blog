## 数组扁平化

数据扁平化，就是把多维数组拍平成一维数组，比如 `[1, [2, [3, [4]], 5]]` 拍平成 `[1, 2, 3, 4, 5]`

实现方法有很多种，我在看到这个问题时，首先想到的是使用 `Array.prototype.flat` 方法和 `for` 递归实现

> `flat()` 方法创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中

```js
const arr = [1, [2, [3, [4]], 5]];

console.log(arr.flat(Infinity)); //[1, 2, 3, 4, 5]
```

`for` 循环递归实现，我的思路：

- 首先 `for` 循环遍历最外层的数组，判断数组内元素是否是数组
  - 如果是数组，继续判断这个数组内元素是否有数组，也就是使用递归来做，要记得最后 `return` 回数据
  - 如果不是数组，直接添加到新数组 `result` 中

```js
const arr = [1, [2, [3, [4]], 5]];

function flattenDeep(arr) {
  if (!Array.isArray(arr)) return [];

  let result = [];
  // 遍历最外层数组
  for (let i = 0; i < arr.length; i++) {
    // 如果是数组，递归调用 flattenDeep 函数
    if (Array.isArray(arr[i])) {
      result = result.concat(flattenDeep(arr[i]));
      console.log(flattenDeep(arr[i]), `<-递归输出`);
    } else {
      // 如果不是数组，直接添加到新数组 result 中
      result.push(arr[i]);
    }
  }
  return result;
}

console.log(flattenDeep(arr)); //[1, 2, 3, 4, 5]
```

在这个例子中，递归的过程就是不断地调用 `flattenDeep` 函数向内层数组遍历，直到遇到的元素不是数组为止，再一层层返回结果

![递归打印结果](https://github.com/user-attachments/assets/e353c337-82ba-4f83-ab40-7202e246ef65)

当然，还有其他办法

利用 `Array` 实例方法 `Array.prototype.map`、`Array.prototype.reduce` 和 `Array.prototype.flatMap` 也可以实现

```js
const arr = [1, [2, [3, [4]], 5]];

// 使用 Array.prototype.map 实现
function mapFlatten(arr) {
  if (!Array.isArray(arr)) return [];
  const result = [];
  return result.concat(
    ...arr.map((item) => (Array.isArray(item) ? mapFlatten(item) : item))
  );
}
console.log(mapFlatten(arr)); //[1, 2, 3, 4, 5]

// 使用 Array.prototype.reduce 实现
function reduceFlatten(arr) {
  if (!Array.isArray(arr)) return [];
  return arr.reduce(
    (prev, cur) => prev.concat(Array.isArray(cur) ? reduceFlatten(cur) : cur),
    []
  );
}

console.log(reduceFlatten(arr)); //[1, 2, 3, 4, 5]

// 使用 Array.prototype.flatMap 实现
function flatMapFlatten(arr) {
  if (!Array.isArray(arr)) return [];
  return arr.flatMap((item) =>
    Array.isArray(item) ? flatMapFlatten(item) : item
  );
}

console.log(flatMapFlatten(arr)); //[1, 2, 3, 4, 5]
```

上面列举了多个能够满足多维数组扁平化要求的函数，如果现在想要加多一个功能：允许指定递归深度，该怎么做？

- 在上面 `flattenDeep` 函数的基础上，添加一个参数 `depth`，表示递归深度，默认值为 1
- 在 `for` 循环中判断当前递归深度是否大于 0
  - 如果大于 0，递归调用 `flattenDeep` 函数，深度每次减 1
  - 否则，直接添加到新数组 `result` 中

> 参考思路： lodash 源码 `_.flattenDeep`

```js
/**
 * 数组扁平化
 * @param {Array} arr 要扁平化的数组
 * @param {number} depth 递归深度，默认值为 1
 * @returns {Array} 扁平化后的数组
 */
function flattenDeep(arr, depth = 1) {
  if (!Array.isArray(arr)) return [];

  let result = [];

  for (let i = 0; i < arr.length; i++) {
    if (depth > 0 && Array.isArray(arr[i])) {
      // 每次递归深度 - 1
      result = result.concat(flattenDeep(arr[i], depth - 1));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}

const arr = [1, [2, [3, [4]], 5]];

console.log(flattenDeep(arr, 1)); //[1, 2, [3, [4]], 5]
```

## 参考资料
- [JavaScript专题之数组扁平化](https://github.com/mqyqingfeng/Blog/issues/36)
- [MDN - Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)
- [lodash - flattenDeep](https://www.lodashjs.com/docs/lodash.flattenDeep)
