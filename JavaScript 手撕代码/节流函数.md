## 节流函数

节流（throttle）：是指在一定时间间隔内，事件只执行一次

写节流函数目前有两种实现方式：时间戳版和定时器版

1. 时间戳版，通过时间运算和与设定时间比较的条件判断来执行事件
2. 定时器版，主要通过 `setTimeout` 来实现，看是否有定时器在运行

多理解上面的话，才能有思路写节流函数

## 时间戳版的节流函数

时间戳版思路：

- 和防抖一样，参数传入 `func` 函数和等待时间 `wait`
- 需要有这几个变量：
  - 记录上次调用时间戳 `lastInvokeTime`
  - 当前什么时间？`currentTime`
- 拿时间来做判断，当前时间 `currentTime` 减去上次调用时间 `lastInvokeTime` 是否会大于设置的等待时间 `wait`
  - 如果大于，表示距离上次调用已经超过了等待时间，允许执行事件，执行完要记得把当前时间记录为上次调用时间 `lastInvokeTime`
  - 如果小于，表示还没到等待时间，不执行事件

```js
function throttle(func, wait) {
  // 上次调用时间戳，初始值为 0
  let lastInvokeTime = 0;
  // 上下文
  let context;
  // 参数
  let args;

  return function () {
    // 保存上下文和参数
    context = this;
    args = arguments;
    // 当前时间戳
    const currentTime = Date.now();
    // 如果当前时间戳 - 上次调用时间戳 > 等待时间，才允许执行事件
    if (currentTime - lastInvokeTime > wait) {
      // 函数显式绑定 this，并且接收传入的参数
      func.apply(context, args);
      // 把当前时间记录为上次调用时间
      lastInvokeTime = currentTime;
    }
  };
}
```

使用时间戳版的节流函数，事件会立即执行，因为 `lastInvokeTime` 变量初始值为 0

## 定时器版的节流函数

节流的第二种实现方法是定时器版：

- 一样的，参数传入 `func` 函数和等待时间 `wait`
- 写防抖的时候，我们也是拿定时器 ID 来判断是否有定时器的，这里也一样
  - 如果 `timeoutId` 有值，说明有定时器在运行，说明是在设定的等待时间内，不允许执行事件
  - 如果 `timeoutId` 为 `null`，两种情况：初次调用和定时器执行完了，允许执行事件
- 注意 `func` 函数的参数和 `this` 指向别丢了，显式绑定 `this` 和传入参数

```js
function throttle(func, wait) {
  // 定时器ID
  let timeoutId;
  // 上下文
  let context;
  // 参数
  let args;

  return function () {
    // 保存上下文和参数
    context = this;
    args = arguments;
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        func.apply(context, args);
        timeoutId = null;
      }, wait);
    }
  };
}
```

定时器版的节流函数，在停止触发事件后，还会再执行一次事件，因为定时器是异步的

> 假设你定了一个 1 秒钟的定时器，在 0.9 秒后停止触发事件，但定时器还在倒计时，到了 1 秒，定时器就会执行事件

## 结合时间戳和定时器版的节流函数

结合时间戳和定时器版的节流函数，我们可以实现一个事件立即执行，然后停止触发事件后，还能再执行一次事件的节流函数

- 首先把节流的基本架子搭起来，传入 `func`、`wait` 两个参数，要返回一个函数，主要逻辑是：
- 有没有到时间，这次我们算剩下时间(remaining)：`wait` 等待时间减去当前时间 `currentTime` 减去上次调用时间 `lastInvokeTime`
  - 时间到了，立即执行事件，要注意清除掉当前如果在执行的定时器
  - 时间没到，要设置一个定时器，确保停止触发的时候还能再执行一次

```js
function throttle(func, wait) {
  // 定时器ID
  let timeoutId;
  // 上次调用时间戳，初始值为 0
  let lastInvokeTime = 0;
  // 上下文
  let context;
  // 参数
  let args;

  return function () {
    // 当前时间戳
    const currentTime = Date.now();
    // 剩余时间
    const remaining = wait - (currentTime - lastInvokeTime);
    // 保存上下文和参数
    context = this;
    args = arguments;

    // 时间到了，要执行，remaining > wait 是为了防止用户手动调整系统时间，导致 remaining 为负数
    if (remaining <= 0 || remaining > wait) {
      // 我现在要执行事件了，在定时的定时器在清除掉
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      // 时间戳的逻辑代码
      func.apply(context, args);
      // 把当前时间记录为上次调用时间
      lastInvokeTime = currentTime;
    }
    // 时间没到并且没有定时器，设置一个定时器
    else if (!timeoutId) {
      // 定时器的逻辑代码
      // 设置定时器，时间为剩下的时间 remaining
      timeoutId = setTimeout(() => {
        // 定时器执行完了，要把上次调用时间记录为当前时间
        lastInvokeTime = Date.now();
        func.apply(context, args);
        timeoutId = null;
      }, remaining);
    }
  };
}
```

## 参考资料

- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)
